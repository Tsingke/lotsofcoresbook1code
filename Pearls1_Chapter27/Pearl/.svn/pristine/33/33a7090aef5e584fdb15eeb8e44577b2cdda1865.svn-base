For compiling the Sparse Library and MulticoreBSP for C on a regular Linux-based system: simply download the source code, unpack, and issue `make' from a command-line terminal. All should compile out of the box. Note that the Sparse Library does require the libnuma library to be installed.

Compiling and running the code on the Xeon Phi is not the default compilation option and requires a little bit more work:

Sparse Library, Xeon Phi
------------------------

1. Get and unpack the Sparse Library code; any version higher than 1.5.2 contains the vectorized kernel. (Note that the book comes with a preview release of version 1.6.0.)

2. Edit the Makefile.
   a. Look for the text `#start compiler choices'
   b. Comment the lines corresponding to the GNU Compiler Collection (GCC), since
      we want to compile for the Xeon Phi using the Intel C++ Compiler (ICC)
   c. Scroll down to the compiler option 2b and uncomment those lines
   d. Check the path to the ICC compiler you have installed

An example, using no full path to an ICC installation:

#start compiler choices
#<cut>
#2: Intel Compiler Collection (ICC)
#IPATH=/opt/intel/composer_xe_2013_sp1.1.106/
# <cut>
# b: performance mode, Xeon Phi target
CC=icc -diag-disable 654 -diag-disable 68
CILK=icc
CFLAGS=-mmic -O3 -openmp -DNDEBUG -D_NO_LIBNUMA
CMSG="ICC performance flags -- MIC target"
LFLAGS=-pthread -lrt
#end compiler choices

(Note that this assumes all Intel MKL features (see later in the Makefile) are commented out. Compilation *with* MKL requires IPATH to be set to the location of your Intel C++ Compiler location.)

3. Compile the benchmark programs:

    make driver
    make micbench

4. To prepare to run these programs, copy them to your mic card. Example:

   scp driver micbench mic0:~/

Your installation does require the Xeon Phi card to have access to a dynamic OpenMP library. On some systems, this may require manual copying as well:

   scp /opt/intel/composer_xe_2013_sp1.1.106/compiler/lib/mic/libiomp5.so mic0:~/

For usage information, simply run the programs without parameters:

   ssh mic0
   ./micbench
   ./driver

If your system requires the dynamic OpenMP library to be made available manually, this has to be preceded by setting the LD_LIBRARY_PATH to the correct location. Example (in-line with the previous):

    ssh mic0
    export LD_LIBRARY_PATH=.;./micbench
    export LD_LIBRARY_PATH=.;./driver

5. Both benchmark applications require input matrices in Matrix Market format. One can retrieve such input sparse matrices from the University of Florida Sparse Matrix Collection at:

    http://www.cise.ufl.edu/research/sparse/matrices/

By example (from the host, after copying the benchmark files in step 4)::

    wget http://www.cise.ufl.edu/research/sparse/MM/GHS_psdef/s3dkt3m2.tar.gz
    tar xvfz s3dkt3m2.tar.gz
    scp s3dkt3m2/s3dkt3m2.mtx mic0:~/
    ssh mic0

First set the number of threads to use. Assuming 60 cores are available and assuming we are using the full 4 threads per core:

    echo 240 > hardware.info

And then start the benchmark:

    export LD_LIBRARY_PATH=.;./micbench s3dkt3m2.mtx 8 1

Note: the practical use of the software for inclusion in perhaps your own applications, is illustrated by the source code of these benchmark applications, i.e., `driver.cpp' and `micbench.cpp'. Source code documentation is available and can be generated by issuing from a command-line terminal:

    make docs

For more information, simply issue

    make help


MulticoreBSP for C, Xeon Phi
----------------------------

1. Get and unpack

    http://multicorebsp.com/downloads/c/1.2.0/MulticoreBSP-for-C.tar.gz

(or a later version that may be available; check www.multicorebsp.com)

2. Set machine-specific defaults; from a terminal, issue

    make include.mk

And edit the newly created include.mk to work with ICC, and add -mmic to the ICC CFLAGS (replace `CFLAGS=-Wall ${OPT} -I.' with `CFLAGS=-Wall ${OPT} -I. -mmic').

3. Make the library and some of the standard library tests; issue

    make test

4. Copy the newly created executables to the MIC, and run the tests manually. For example:

    scp -r ./test* mic0:~/
    ssh mic0
    cp tests/machine.info ./
    ./test_internal
    ./test_bsp
    ./test_spmd
    ./test_util || echo "SUCCESS"
    ./test_abort 2> tests/test_abort.out; diff tests/test_abort.out tests/test_abort.chk && echo "SUCCESS"
    rm machine.info

(All these tests should display SUCCESS.)


License and attribution
-----------------------

This code is available under the GPL version 3. If you find this code useful for 
your work or research, please cite the relevant paper(s) from the below:

* One of the parallel methods for sparse matrix-vector (SpMV) multiplication:

    High-Level Strategies for Parallel Shared-Memory Sparse Matrix–Vector Multiplication
    by A. N. Yzelman & D. Roose
    in IEEE Transactions on Parallel and Distributed Systems, 25(1), pp. 116-125 (2014).

* The parallel 2D SpMV method:

    MulticoreBSP for C: a high-performance library for shared-memory parallel programming
    by A. N. Yzelman, R. H. Bisseling, D. Roose, and K. Meerbergen in International Journal of Parallel Programming, in press (2013).

* A (basic) Java implementation of the parallel 2D SpMV method (http://www.multicorebsp.com):

    An Object-Oriented Bulk Synchronous Parallel Library for Multicore Programming
    by A. N. Yzelman & Rob H. Bisseling in Concurrency and Computation: Practice and Experience 24(5), pp. 533-553 (2012).

* The sequential SpMV multiplication based on the Hilbert space-filling curve:

    A cache-oblivious sparse matrix-vector multiplication scheme based on the Hilbert curve
    by A. N. Yzelman & Rob H. Bisseling in M. Günther, A. Bartel, M. Brunk, S. Schöps, and M. Striebel (eds.),
    Progress in Industrial Mathematics at ECMI 2010, pp. 627-634, Springer, 2012.

* The sequential SpMV multiplication based on a 1D reordering of input matrices:

    Cache-oblivious sparse matrix-vector multiplication by using sparse matrix partitioning methods
    by A. N. Yzelman & Rob H. Bisseling in SIAM Journal of Scientific Computation 31(4), pp. 3128-3154 (2009).

* The sequential SpMV multiplication based on a 2D reordering of input matrices:

    Two-dimensional cache-oblivious sparse matrix-vector multiplication
    by A. N. Yzelman & Rob H. Bisseling in Parallel Computing 37(12), pp. 806-819 (2011).

* A distributed-memory 2D SpMV multiplication:

    Two-dimensional approaches to sparse matrix partitioning
    by R. H. Bisseling, B. O. Fagginger Auer, A. N. Yzelman, T. van Leeuwen & Ü. V. Çatalyürek, in Uwe Naumann & Olaf Schenk (eds.),
    Combinatorial Scientific Computing, pp. 321--349, Chapman & Hall / CRC Press, 2012.

